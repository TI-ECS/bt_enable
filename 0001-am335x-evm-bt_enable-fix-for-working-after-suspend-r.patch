From 3f975b364607fcc2571e0d5374b99c54b68ff7d9 Mon Sep 17 00:00:00 2001
From: Eyal Reizer <eyalr@ti.com>
Date: Thu, 29 Mar 2012 10:12:25 +0200
Subject: [PATCH] am335x-evm-bt_enable: fix for working after suspend/resume

* For am335x after each suspend/resume the gpio direction needs to
  be reconfigured to output mode, so we use use the
  gpio_direction_output API instead of gpio_set_value

* Disable the pull-up on the bt_enable pin in case bluetooth
  is off and enable it in case it is on so it remains active
  during suspend

Signed-off-by: Eyal Reizer <eyalr@ti.com>
---
 gpio_en_am335x.c |   38 +++++++++++++++++++++++++++++++++++---
 1 files changed, 35 insertions(+), 3 deletions(-)

diff --git a/gpio_en_am335x.c b/gpio_en_am335x.c
index 601e585..aed0241 100755
--- a/gpio_en_am335x.c
+++ b/gpio_en_am335x.c
@@ -40,9 +40,22 @@
 #include <linux/delay.h>
 #include <linux/gpio.h>
 
+#define AM33XX_CTRL_REGADDR(reg)					\
+		AM33XX_L4_WK_IO_ADDRESS(AM33XX_SCM_BASE + (reg))
+
+/* bit 3: 0 - enable, 1 - disable for pull enable */
+#define AM33XX_PULL_DISA		(1 << 3)
+#define AM33XX_PULL_ENBL		(0 << 3)
+
 /* Convert GPIO signal to GPIO pin number */
 #define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
 
+/* Bluetooth Enable PAD for EVM Rev 1.1 and up */
+#define AM33XX_CONTROL_PADCONF_MCASP0_AHCLKX_OFFSET		0x09AC
+
+/* Bluetooth Enable PAD for EVM Rev 1.0 */
+#define AM33XX_CONTROL_PADCONF_GPMC_CSN2_OFFSET			0x0884
+
 /* 
    Define wl12xx_platform_data prototype here for using with first kernel versions
    that didn't pass the enable pins elements 
@@ -62,6 +75,8 @@ struct wl12xx_platform_data {
 const struct wl12xx_platform_data *wl12xx_get_platform_data(void);
 
 unsigned char bt_enable_pin;
+int selected_pad;
+int pad_mux_value;
 
 static int __init gpio_test_init(void)
 {
@@ -77,18 +92,35 @@ static int __init gpio_test_init(void)
 		bt_enable_pin = GPIO_TO_PIN(1, 31); 
 	}
 
+	/* Select pad conf register based on EVM board rev */
+	if ( bt_enable_pin == GPIO_TO_PIN(3, 21) )	
+		selected_pad = AM33XX_CONTROL_PADCONF_MCASP0_AHCLKX_OFFSET;
+	else
+		selected_pad = AM33XX_CONTROL_PADCONF_GPMC_CSN2_OFFSET;
+ 
 	printk("Gpio value is :%d\n", bt_enable_pin);
-	gpio_set_value(bt_enable_pin, 0);
+	gpio_direction_output(bt_enable_pin, 0);
 	msleep(1);
 	printk("WL1271: BT Enable\n");
-	gpio_set_value(bt_enable_pin, 1);
+	gpio_direction_output(bt_enable_pin, 1);
+
+	/* Enable pullup on the enable pin for keeping BT active during suspend */
+	pad_mux_value = readl(AM33XX_CTRL_REGADDR(selected_pad));
+	pad_mux_value &= (~AM33XX_PULL_DISA);
+	writel(pad_mux_value, AM33XX_CTRL_REGADDR(selected_pad));
+
 	return 0;
 }
 
 static void __exit gpio_test_exit(void)
 {
 	printk("WL1271: BT Disable\n");
-        gpio_set_value(bt_enable_pin, 0);
+        gpio_direction_output(bt_enable_pin, 0);
+
+	/* Disable pullup on the enable pin to allow BT shut down during suspend */
+	pad_mux_value = readl(AM33XX_CTRL_REGADDR(selected_pad));
+	pad_mux_value |= AM33XX_PULL_DISA;
+	writel(pad_mux_value, AM33XX_CTRL_REGADDR(selected_pad));
 }
 
 
-- 
1.7.0.4

